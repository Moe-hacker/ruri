# 用法：
```
ruri [选项]...
ruri [参数]... [容器目录]... [命令 [参数]...]
```

## 选项：
```
-v, --version ...............................: 显示版本信息
-V, --version-code ..........................: 显示版本代码
-h, --help ..................................: 显示帮助
-H, --show-examples .........................: 显示命令行示例
-P, --ps [container_dir/config]..............: 显示容器进程信息
```
这四个选项将显示相关信息。
********************************************
```
-U, --umount [container_dir/config] .........: 卸载容器
```
在运行容器时，ruri需要挂载一些目录。  
在运行完容器后，可以使用`-U`选项来卸载容器。  
该选项需要以root身份（使用 sudo）运行。  
警告：在删除容器之前，请运行`sudo ruri -U /path/to/container`。  
```
-C, --correct-config..............: 修正配置文件
```
尝试修正不全的配置文件。      
## 参数：
常规的ruri容器应使用sudo运行，但如果您想运行rootless容器，也可以使用`-r`选项。  
*****************************************
```
-D, --dump-config ...........................: 导出配置
```
ruri 支持使用配置文件，您可以使用`-D`选项导出当前容器的配置。  
例如：  
```
ruri -D -k cap_sys_admin -d cap_sys_chroot ./t
```
这将导出使用`-k cap_sys_admin -d cap_sys_chroot`选项配置的容器配置，下次您只需使用配置文件，而不是重复输入这些参数。  
********************************************
```
-o, --output [config file] ..................: 设置`-D`选项的输出文件
```
此选项用于`-D`选项，将配置保存到文件中。  
例如：
```
ruri -D -o test.conf -k cap_sys_admin -d cap_sys_chroot ./t
```
将会把配置文件保存到test.conf。  
*****************************************
```
-c, --config [config] [args] [COMMAND [ARGS]]: 使用配置文件
```
您可以使用`ruri -c config_file`来使用配置文件运行容器。  
例如：  
```
ruri -c test.conf
```
这将使用test.conf运行容器。
或者：      
```
ruri -c test.conf -k cap_sys_admin /bin/su root -
```      
***********************************************
```      
-a, --arch [arch] ...........................: 通过binfmt_misc/QEMU模拟架构
-q, --qemu-path [path] ......................: 指定QEMU的路径
```
这两个参数需要同时设置。  
ruri 支持使用qemu-user-static和内核的binfmt_misc特性来运行跨架构容器。  
`-q`选项可以使用主机中的qemu路径，它将被复制到容器中的/qemu-ruri。  
例如：  
```
ruri -q /usr/bin/qemu-x86_64-static -a x86_64 ./test-x86_64
```
但请记住，`-a`选项不应该和宿主机架构相同。  
*******************************************************************
```
-u, --unshare ...............................: 启用unshare功能
```
ruri支持unshare容器，但不支持NET和USER命名空间。  
注意，当PID 1退出时，整个PID NS会被销毁，里面所有进程将被kill。      
*****************************************
```
-n, --no-new-privs ..........................: 设置NO_NEW_PRIVS标志
```
此参数将设置NO_NEW_PRIVS位，普通用户将无法使用`sudo`等命令。  
****************************************
```
-N, --no-rurienv ............................: 不使用.rurienv文件
```
ruri 默认会在容器中创建/.rurienv来保存容器配置，可以使用此选项禁用它。  
********************************
```
-J, --join-ns [NS_PID].......................: 加入NS_PID的命名空间
```
对于开启-N选项的unshare/rootless容器，您可以使用此选项加入其命名空间。      
此选项仅对开启了`-uN`或`-rN`选项的容器适用。      
*********************************************
```
-s, --enable-seccomp ........................: 启用内置Seccomp配置
```
ruri提供了内置的seccomp配置，但如果您确实需要使用seccomp，可能需要编辑src/seccomp.c，使用自己的seccomp配置并重新编译。  
****************************************
```
-p, --privileged ............................: 以特权模式运行容器
```
此参数将给容器所有capability，但您也可以使用`-d`选项过滤掉不想保留的capability。  
*******************************************
```
-r, --rootless ..............................: 运行rootless容器
```
此选项应以普通用户身份运行，支持运行rootless容器。  
此选项需要`uidmap`软件包和User ns支持。  
********************************************
```
-k, --keep [cap] ............................: 保留指定的cap
-d, --drop [cap] ............................: 删除指定的cap
```
这两个选项可以控制容器中的capability，cap可以是值或名称。  
例如，`-k cap_chown`与`-k 0`的效果相同。  
**************************************************
```
-e, --env [env] [value] .....................: 设置环境变量及其值
```
一个非常没用的功能，希望它能正常运行。  
*********************************************
```
-m, --mount [dir/dev/img/file] [target] .....: 挂载目录/块设备/镜像/文件到目标
-M, --ro-mount [dir/dev/img/file] [target] ..: 以只读方式挂载目录/块设备/镜像/文件
```
ruri 提供了强大的挂载功能，以下是一些示例：
```
ruri -m /dev/sda1 / ./test
```
此命令将/dev/sda1挂载到./test并运行容器。  
```
ruri -m ./test.img / ./test
```
此命令将./test.img挂载到./test并运行容器。  
```
ruri -m /sdcard /sdcard ./test
```
此命令将/sdcard挂载到./test/sdcard并运行容器。    
******************************************
```
-S, --host-runtime ..........................: 从主机绑定挂载/dev/、/sys/和/proc/
```
为了安全性，ruri会在chroot()后再创建/dev, /proc和/sys目录以及里面的文件，您可以使用-S选项来挂载宿主机上的运行时目录而非由ruri创建。    
*************************************
```
-R, --read-only .............................: 将/挂载为只读
```
这将使整个容器的根文件系统变为只读。
***********************************************
```
-l, --limit [cpuset=cpu/memory=mem] .........: 设置cpuset/memory限制
```
ruri目前支持cpuset和memory cgroup。  
每个`-l`选项只能设置一个 cpuset/memory 限制。  
例如：  
```
ruri -l memory=1M -l cpuset=1 /test
```
**************************************************
```
-w, --no-warnings ...........................: 禁用警告
```
运行ruri时可能会出现一些警告，可以使用`-w`选项来禁用它们。         
********************************************
```
-f, --fork .............................:在执行命令前fork()一次
```      
unshare容器和rootless容器会始终在执行命令前fork()自身一次，     
使用此选项使普通chroot容器拥有相同行为.     
************************
```
-j, --just-chroot ...........................: 仅chroot，不创建/dev，/sys和/proc
```
使用此选项避免ruri创建/dev，/sys和/proc。        
*******************
```
-W, --work-dir ..............................: 更改容器中的工作目录，默认是/
```
出于兼容性考虑，增加此选项。          
****************
```
-A, --unmask-dirs ...........................: 不保护/proc和/sys中的目录
```
默认情况下，ruri将会遮盖/proc和/sys下的敏感位置，使用此选项取消此行为。         
***************
```
-E, --user [user/uid] .......................: 使用user在容器中执行命令而非root
```
你可以使用此选项在exec(3)前切换到指定用户以降低权限。      
*************
```
-t, --hostname [hostname] ...................: 设置主机名
```
设置主机名，仅供unshare容器。      
**************
```
-x, --no-network .......................: 禁用网络
```      
禁用容器网络，这需要net命名空间支持，并将自动启用unshare。      
************
```
-K, --use-kvm ..........................: 开启/dev/kvm支持
```
开启/dev/kvm支持。      
********
```
-I, --char-dev [device] [major] [minor] .....: 添加一个字符设备
```
例如 `-I kvm 10 232` 或 `-I dri/card0 226 0`.         
*********
```
-i, --hidepid 1/2 ...........................: /proc挂载的hidepid选项
```
例如 `-i 1`      
*********
```
-b, --background ............................: 后台运行
-L, --logfile [file] ........................: 日志文件，用于-b参数
```
后台运行ruri并输出到日志。      
**********      
```
-X，--deny-syscall [syscall].................:阻止某个syscall

```
使用seccomp直接对某个syscall设置SCMP_ACT_KILL。      
